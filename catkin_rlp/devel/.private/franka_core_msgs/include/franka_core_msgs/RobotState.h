// Generated by gencpp from file franka_core_msgs/RobotState.msg
// DO NOT EDIT!


#ifndef FRANKA_CORE_MSGS_MESSAGE_ROBOTSTATE_H
#define FRANKA_CORE_MSGS_MESSAGE_ROBOTSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <franka_msgs/Errors.h>
#include <franka_msgs/Errors.h>

namespace franka_core_msgs
{
template <class ContainerAllocator>
struct RobotState_
{
  typedef RobotState_<ContainerAllocator> Type;

  RobotState_()
    : header()
    , cartesian_collision()
    , cartesian_contact()
    , O_dP_EE()
    , q_d()
    , dq_d()
    , dtau_J()
    , tau_J_d()
    , joint_collision()
    , joint_contact()
    , tau_ext_hat_filtered()
    , F_x_Cee()
    , F_x_Cload()
    , F_x_Ctotal()
    , I_ee()
    , I_load()
    , I_total()
    , m_ee(0.0)
    , m_load(0.0)
    , m_total(0.0)
    , gravity()
    , coriolis()
    , mass_matrix()
    , O_Jac_EE()
    , O_T_EE_d()
    , F_T_EE()
    , F_T_NE()
    , NE_T_EE()
    , EE_T_K()
    , time(0.0)
    , robot_mode(0)
    , current_errors()
    , last_motion_errors()  {
      cartesian_collision.assign(0.0);

      cartesian_contact.assign(0.0);

      O_dP_EE.assign(0.0);

      q_d.assign(0.0);

      dq_d.assign(0.0);

      dtau_J.assign(0.0);

      tau_J_d.assign(0.0);

      joint_collision.assign(0.0);

      joint_contact.assign(0.0);

      tau_ext_hat_filtered.assign(0.0);

      F_x_Cee.assign(0.0);

      F_x_Cload.assign(0.0);

      F_x_Ctotal.assign(0.0);

      I_ee.assign(0.0);

      I_load.assign(0.0);

      I_total.assign(0.0);

      gravity.assign(0.0);

      coriolis.assign(0.0);

      mass_matrix.assign(0.0);

      O_Jac_EE.assign(0.0);

      O_T_EE_d.assign(0.0);

      F_T_EE.assign(0.0);

      F_T_NE.assign(0.0);

      NE_T_EE.assign(0.0);

      EE_T_K.assign(0.0);
  }
  RobotState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , cartesian_collision()
    , cartesian_contact()
    , O_dP_EE()
    , q_d()
    , dq_d()
    , dtau_J()
    , tau_J_d()
    , joint_collision()
    , joint_contact()
    , tau_ext_hat_filtered()
    , F_x_Cee()
    , F_x_Cload()
    , F_x_Ctotal()
    , I_ee()
    , I_load()
    , I_total()
    , m_ee(0.0)
    , m_load(0.0)
    , m_total(0.0)
    , gravity()
    , coriolis()
    , mass_matrix()
    , O_Jac_EE()
    , O_T_EE_d()
    , F_T_EE()
    , F_T_NE()
    , NE_T_EE()
    , EE_T_K()
    , time(0.0)
    , robot_mode(0)
    , current_errors(_alloc)
    , last_motion_errors(_alloc)  {
  (void)_alloc;
      cartesian_collision.assign(0.0);

      cartesian_contact.assign(0.0);

      O_dP_EE.assign(0.0);

      q_d.assign(0.0);

      dq_d.assign(0.0);

      dtau_J.assign(0.0);

      tau_J_d.assign(0.0);

      joint_collision.assign(0.0);

      joint_contact.assign(0.0);

      tau_ext_hat_filtered.assign(0.0);

      F_x_Cee.assign(0.0);

      F_x_Cload.assign(0.0);

      F_x_Ctotal.assign(0.0);

      I_ee.assign(0.0);

      I_load.assign(0.0);

      I_total.assign(0.0);

      gravity.assign(0.0);

      coriolis.assign(0.0);

      mass_matrix.assign(0.0);

      O_Jac_EE.assign(0.0);

      O_T_EE_d.assign(0.0);

      F_T_EE.assign(0.0);

      F_T_NE.assign(0.0);

      NE_T_EE.assign(0.0);

      EE_T_K.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef boost::array<double, 6>  _cartesian_collision_type;
  _cartesian_collision_type cartesian_collision;

   typedef boost::array<double, 6>  _cartesian_contact_type;
  _cartesian_contact_type cartesian_contact;

   typedef boost::array<double, 6>  _O_dP_EE_type;
  _O_dP_EE_type O_dP_EE;

   typedef boost::array<double, 7>  _q_d_type;
  _q_d_type q_d;

   typedef boost::array<double, 7>  _dq_d_type;
  _dq_d_type dq_d;

   typedef boost::array<double, 7>  _dtau_J_type;
  _dtau_J_type dtau_J;

   typedef boost::array<double, 7>  _tau_J_d_type;
  _tau_J_d_type tau_J_d;

   typedef boost::array<double, 7>  _joint_collision_type;
  _joint_collision_type joint_collision;

   typedef boost::array<double, 7>  _joint_contact_type;
  _joint_contact_type joint_contact;

   typedef boost::array<double, 7>  _tau_ext_hat_filtered_type;
  _tau_ext_hat_filtered_type tau_ext_hat_filtered;

   typedef boost::array<double, 3>  _F_x_Cee_type;
  _F_x_Cee_type F_x_Cee;

   typedef boost::array<double, 3>  _F_x_Cload_type;
  _F_x_Cload_type F_x_Cload;

   typedef boost::array<double, 3>  _F_x_Ctotal_type;
  _F_x_Ctotal_type F_x_Ctotal;

   typedef boost::array<double, 9>  _I_ee_type;
  _I_ee_type I_ee;

   typedef boost::array<double, 9>  _I_load_type;
  _I_load_type I_load;

   typedef boost::array<double, 9>  _I_total_type;
  _I_total_type I_total;

   typedef double _m_ee_type;
  _m_ee_type m_ee;

   typedef double _m_load_type;
  _m_load_type m_load;

   typedef double _m_total_type;
  _m_total_type m_total;

   typedef boost::array<double, 7>  _gravity_type;
  _gravity_type gravity;

   typedef boost::array<double, 7>  _coriolis_type;
  _coriolis_type coriolis;

   typedef boost::array<double, 49>  _mass_matrix_type;
  _mass_matrix_type mass_matrix;

   typedef boost::array<double, 42>  _O_Jac_EE_type;
  _O_Jac_EE_type O_Jac_EE;

   typedef boost::array<double, 16>  _O_T_EE_d_type;
  _O_T_EE_d_type O_T_EE_d;

   typedef boost::array<double, 16>  _F_T_EE_type;
  _F_T_EE_type F_T_EE;

   typedef boost::array<double, 16>  _F_T_NE_type;
  _F_T_NE_type F_T_NE;

   typedef boost::array<double, 16>  _NE_T_EE_type;
  _NE_T_EE_type NE_T_EE;

   typedef boost::array<double, 16>  _EE_T_K_type;
  _EE_T_K_type EE_T_K;

   typedef double _time_type;
  _time_type time;

   typedef uint8_t _robot_mode_type;
  _robot_mode_type robot_mode;

   typedef  ::franka_msgs::Errors_<ContainerAllocator>  _current_errors_type;
  _current_errors_type current_errors;

   typedef  ::franka_msgs::Errors_<ContainerAllocator>  _last_motion_errors_type;
  _last_motion_errors_type last_motion_errors;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(ROBOT_MODE_OTHER)
  #undef ROBOT_MODE_OTHER
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_IDLE)
  #undef ROBOT_MODE_IDLE
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_MOVE)
  #undef ROBOT_MODE_MOVE
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_GUIDING)
  #undef ROBOT_MODE_GUIDING
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_REFLEX)
  #undef ROBOT_MODE_REFLEX
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_USER_STOPPED)
  #undef ROBOT_MODE_USER_STOPPED
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY)
  #undef ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY
#endif

  enum {
    ROBOT_MODE_OTHER = 0u,
    ROBOT_MODE_IDLE = 1u,
    ROBOT_MODE_MOVE = 2u,
    ROBOT_MODE_GUIDING = 3u,
    ROBOT_MODE_REFLEX = 4u,
    ROBOT_MODE_USER_STOPPED = 5u,
    ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY = 6u,
  };


  typedef boost::shared_ptr< ::franka_core_msgs::RobotState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::franka_core_msgs::RobotState_<ContainerAllocator> const> ConstPtr;

}; // struct RobotState_

typedef ::franka_core_msgs::RobotState_<std::allocator<void> > RobotState;

typedef boost::shared_ptr< ::franka_core_msgs::RobotState > RobotStatePtr;
typedef boost::shared_ptr< ::franka_core_msgs::RobotState const> RobotStateConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::franka_core_msgs::RobotState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::franka_core_msgs::RobotState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::franka_core_msgs::RobotState_<ContainerAllocator1> & lhs, const ::franka_core_msgs::RobotState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.cartesian_collision == rhs.cartesian_collision &&
    lhs.cartesian_contact == rhs.cartesian_contact &&
    lhs.O_dP_EE == rhs.O_dP_EE &&
    lhs.q_d == rhs.q_d &&
    lhs.dq_d == rhs.dq_d &&
    lhs.dtau_J == rhs.dtau_J &&
    lhs.tau_J_d == rhs.tau_J_d &&
    lhs.joint_collision == rhs.joint_collision &&
    lhs.joint_contact == rhs.joint_contact &&
    lhs.tau_ext_hat_filtered == rhs.tau_ext_hat_filtered &&
    lhs.F_x_Cee == rhs.F_x_Cee &&
    lhs.F_x_Cload == rhs.F_x_Cload &&
    lhs.F_x_Ctotal == rhs.F_x_Ctotal &&
    lhs.I_ee == rhs.I_ee &&
    lhs.I_load == rhs.I_load &&
    lhs.I_total == rhs.I_total &&
    lhs.m_ee == rhs.m_ee &&
    lhs.m_load == rhs.m_load &&
    lhs.m_total == rhs.m_total &&
    lhs.gravity == rhs.gravity &&
    lhs.coriolis == rhs.coriolis &&
    lhs.mass_matrix == rhs.mass_matrix &&
    lhs.O_Jac_EE == rhs.O_Jac_EE &&
    lhs.O_T_EE_d == rhs.O_T_EE_d &&
    lhs.F_T_EE == rhs.F_T_EE &&
    lhs.F_T_NE == rhs.F_T_NE &&
    lhs.NE_T_EE == rhs.NE_T_EE &&
    lhs.EE_T_K == rhs.EE_T_K &&
    lhs.time == rhs.time &&
    lhs.robot_mode == rhs.robot_mode &&
    lhs.current_errors == rhs.current_errors &&
    lhs.last_motion_errors == rhs.last_motion_errors;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::franka_core_msgs::RobotState_<ContainerAllocator1> & lhs, const ::franka_core_msgs::RobotState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace franka_core_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::franka_core_msgs::RobotState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::franka_core_msgs::RobotState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::franka_core_msgs::RobotState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::franka_core_msgs::RobotState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::franka_core_msgs::RobotState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::franka_core_msgs::RobotState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::franka_core_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "380ed6f93e2f9638a809e6b00ef7462c";
  }

  static const char* value(const ::franka_core_msgs::RobotState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x380ed6f93e2f9638ULL;
  static const uint64_t static_value2 = 0xa809e6b00ef7462cULL;
};

template<class ContainerAllocator>
struct DataType< ::franka_core_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "franka_core_msgs/RobotState";
  }

  static const char* value(const ::franka_core_msgs::RobotState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::franka_core_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n"
"\n"
"float64[6] cartesian_collision\n"
"float64[6] cartesian_contact\n"
"float64[6] O_dP_EE # EE vel computed as J*dq\n"
"\n"
"# float64[7] q # joint position, velocity, and effort in joint_states topic\n"
"# float64[7] dq\n"
"\n"
"float64[7] q_d\n"
"float64[7] dq_d\n"
"# float64[7] tau_J\n"
"float64[7] dtau_J # torque derivative\n"
"float64[7] tau_J_d # desired joint torque\n"
"# float64[6] K_F_ext_hat_K\n"
"# float64[2] elbow\n"
"# float64[2] elbow_d\n"
"\n"
"float64[7] joint_collision\n"
"float64[7] joint_contact\n"
"\n"
"# float64[6] O_F_ext_hat_K # in tip state\n"
"\n"
"float64[7] tau_ext_hat_filtered # filtered external torque\n"
"float64[3] F_x_Cee # Configured center of mass of the end effector load with respect to flange frame.\n"
"float64[3] F_x_Cload # Configured center of mass of the external load with respect to flange frame.\n"
"float64[3] F_x_Ctotal # Combined center of mass of the end effector load and the external load with respect to flange frame.\n"
"float64[9] I_ee # Configured rotational inertia matrix of the end effector load with respect to center of mass.\n"
"float64[9] I_load\n"
"float64[9] I_total\n"
"\n"
"float64 m_ee # configured mass of end-effector\n"
"float64 m_load # configured mass of external load\n"
"float64 m_total\n"
"\n"
"\n"
"float64[7] gravity\n"
"float64[7] coriolis\n"
"float64[49] mass_matrix # mass matrix of end-effector wrt base frame # Vectorized 7x7, column-major\n"
"\n"
"float64[42] O_Jac_EE # zero jacobian of end-effector frame. Vectorized 6x7 Jacobian, column-major\n"
"\n"
"# float64[16] O_T_EE # ----- moved to endpointstate msg # Vectorized 4x4, column-major\n"
"float64[16] O_T_EE_d # Last desired end effector pose of motion generation in base frame.  # Vectorized 4x4, column-major\n"
"float64[16] F_T_EE # End effector frame pose in flange frame # Vectorized 4x4, column-major\n"
"float64[16] F_T_NE # Nominal End effector frame pose in flange frame (fixed in Desk) # Vectorized 4x4, column-major\n"
"float64[16] NE_T_EE # End effector frame pose in Nominal End effector frame # Vectorized 4x4, column-major\n"
"float64[16] EE_T_K # Stiffness frame pose in end effector frame # Vectorized 4x4, column-major\n"
"float64 time\n"
"\n"
"uint8 ROBOT_MODE_OTHER=0\n"
"uint8 ROBOT_MODE_IDLE=1\n"
"uint8 ROBOT_MODE_MOVE=2\n"
"uint8 ROBOT_MODE_GUIDING=3\n"
"uint8 ROBOT_MODE_REFLEX=4\n"
"uint8 ROBOT_MODE_USER_STOPPED=5\n"
"uint8 ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY=6\n"
"uint8 robot_mode\n"
"\n"
"franka_msgs/Errors current_errors\n"
"franka_msgs/Errors last_motion_errors\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: franka_msgs/Errors\n"
"bool joint_position_limits_violation\n"
"bool cartesian_position_limits_violation\n"
"bool self_collision_avoidance_violation\n"
"bool joint_velocity_violation\n"
"bool cartesian_velocity_violation\n"
"bool force_control_safety_violation\n"
"bool joint_reflex\n"
"bool cartesian_reflex\n"
"bool max_goal_pose_deviation_violation\n"
"bool max_path_pose_deviation_violation\n"
"bool cartesian_velocity_profile_safety_violation\n"
"bool joint_position_motion_generator_start_pose_invalid\n"
"bool joint_motion_generator_position_limits_violation\n"
"bool joint_motion_generator_velocity_limits_violation\n"
"bool joint_motion_generator_velocity_discontinuity\n"
"bool joint_motion_generator_acceleration_discontinuity\n"
"bool cartesian_position_motion_generator_start_pose_invalid\n"
"bool cartesian_motion_generator_elbow_limit_violation\n"
"bool cartesian_motion_generator_velocity_limits_violation\n"
"bool cartesian_motion_generator_velocity_discontinuity\n"
"bool cartesian_motion_generator_acceleration_discontinuity\n"
"bool cartesian_motion_generator_elbow_sign_inconsistent\n"
"bool cartesian_motion_generator_start_elbow_invalid\n"
"bool cartesian_motion_generator_joint_position_limits_violation\n"
"bool cartesian_motion_generator_joint_velocity_limits_violation\n"
"bool cartesian_motion_generator_joint_velocity_discontinuity\n"
"bool cartesian_motion_generator_joint_acceleration_discontinuity\n"
"bool cartesian_position_motion_generator_invalid_frame\n"
"bool force_controller_desired_force_tolerance_violation\n"
"bool controller_torque_discontinuity\n"
"bool start_elbow_sign_inconsistent\n"
"bool communication_constraints_violation\n"
"bool power_limit_violation\n"
"bool joint_p2p_insufficient_torque_for_planning\n"
"bool tau_j_range_violation\n"
"bool instability_detected\n"
"bool joint_move_in_wrong_direction\n"
"bool cartesian_spline_motion_generator_violation\n"
"bool joint_via_motion_generator_planning_joint_limit_violation\n"
"bool base_acceleration_initialization_timeout\n"
"bool base_acceleration_invalid_reading\n"
;
  }

  static const char* value(const ::franka_core_msgs::RobotState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::franka_core_msgs::RobotState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.cartesian_collision);
      stream.next(m.cartesian_contact);
      stream.next(m.O_dP_EE);
      stream.next(m.q_d);
      stream.next(m.dq_d);
      stream.next(m.dtau_J);
      stream.next(m.tau_J_d);
      stream.next(m.joint_collision);
      stream.next(m.joint_contact);
      stream.next(m.tau_ext_hat_filtered);
      stream.next(m.F_x_Cee);
      stream.next(m.F_x_Cload);
      stream.next(m.F_x_Ctotal);
      stream.next(m.I_ee);
      stream.next(m.I_load);
      stream.next(m.I_total);
      stream.next(m.m_ee);
      stream.next(m.m_load);
      stream.next(m.m_total);
      stream.next(m.gravity);
      stream.next(m.coriolis);
      stream.next(m.mass_matrix);
      stream.next(m.O_Jac_EE);
      stream.next(m.O_T_EE_d);
      stream.next(m.F_T_EE);
      stream.next(m.F_T_NE);
      stream.next(m.NE_T_EE);
      stream.next(m.EE_T_K);
      stream.next(m.time);
      stream.next(m.robot_mode);
      stream.next(m.current_errors);
      stream.next(m.last_motion_errors);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RobotState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::franka_core_msgs::RobotState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::franka_core_msgs::RobotState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "cartesian_collision[]" << std::endl;
    for (size_t i = 0; i < v.cartesian_collision.size(); ++i)
    {
      s << indent << "  cartesian_collision[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cartesian_collision[i]);
    }
    s << indent << "cartesian_contact[]" << std::endl;
    for (size_t i = 0; i < v.cartesian_contact.size(); ++i)
    {
      s << indent << "  cartesian_contact[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cartesian_contact[i]);
    }
    s << indent << "O_dP_EE[]" << std::endl;
    for (size_t i = 0; i < v.O_dP_EE.size(); ++i)
    {
      s << indent << "  O_dP_EE[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_dP_EE[i]);
    }
    s << indent << "q_d[]" << std::endl;
    for (size_t i = 0; i < v.q_d.size(); ++i)
    {
      s << indent << "  q_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.q_d[i]);
    }
    s << indent << "dq_d[]" << std::endl;
    for (size_t i = 0; i < v.dq_d.size(); ++i)
    {
      s << indent << "  dq_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dq_d[i]);
    }
    s << indent << "dtau_J[]" << std::endl;
    for (size_t i = 0; i < v.dtau_J.size(); ++i)
    {
      s << indent << "  dtau_J[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dtau_J[i]);
    }
    s << indent << "tau_J_d[]" << std::endl;
    for (size_t i = 0; i < v.tau_J_d.size(); ++i)
    {
      s << indent << "  tau_J_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tau_J_d[i]);
    }
    s << indent << "joint_collision[]" << std::endl;
    for (size_t i = 0; i < v.joint_collision.size(); ++i)
    {
      s << indent << "  joint_collision[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_collision[i]);
    }
    s << indent << "joint_contact[]" << std::endl;
    for (size_t i = 0; i < v.joint_contact.size(); ++i)
    {
      s << indent << "  joint_contact[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_contact[i]);
    }
    s << indent << "tau_ext_hat_filtered[]" << std::endl;
    for (size_t i = 0; i < v.tau_ext_hat_filtered.size(); ++i)
    {
      s << indent << "  tau_ext_hat_filtered[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tau_ext_hat_filtered[i]);
    }
    s << indent << "F_x_Cee[]" << std::endl;
    for (size_t i = 0; i < v.F_x_Cee.size(); ++i)
    {
      s << indent << "  F_x_Cee[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_x_Cee[i]);
    }
    s << indent << "F_x_Cload[]" << std::endl;
    for (size_t i = 0; i < v.F_x_Cload.size(); ++i)
    {
      s << indent << "  F_x_Cload[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_x_Cload[i]);
    }
    s << indent << "F_x_Ctotal[]" << std::endl;
    for (size_t i = 0; i < v.F_x_Ctotal.size(); ++i)
    {
      s << indent << "  F_x_Ctotal[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_x_Ctotal[i]);
    }
    s << indent << "I_ee[]" << std::endl;
    for (size_t i = 0; i < v.I_ee.size(); ++i)
    {
      s << indent << "  I_ee[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.I_ee[i]);
    }
    s << indent << "I_load[]" << std::endl;
    for (size_t i = 0; i < v.I_load.size(); ++i)
    {
      s << indent << "  I_load[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.I_load[i]);
    }
    s << indent << "I_total[]" << std::endl;
    for (size_t i = 0; i < v.I_total.size(); ++i)
    {
      s << indent << "  I_total[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.I_total[i]);
    }
    s << indent << "m_ee: ";
    Printer<double>::stream(s, indent + "  ", v.m_ee);
    s << indent << "m_load: ";
    Printer<double>::stream(s, indent + "  ", v.m_load);
    s << indent << "m_total: ";
    Printer<double>::stream(s, indent + "  ", v.m_total);
    s << indent << "gravity[]" << std::endl;
    for (size_t i = 0; i < v.gravity.size(); ++i)
    {
      s << indent << "  gravity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.gravity[i]);
    }
    s << indent << "coriolis[]" << std::endl;
    for (size_t i = 0; i < v.coriolis.size(); ++i)
    {
      s << indent << "  coriolis[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.coriolis[i]);
    }
    s << indent << "mass_matrix[]" << std::endl;
    for (size_t i = 0; i < v.mass_matrix.size(); ++i)
    {
      s << indent << "  mass_matrix[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.mass_matrix[i]);
    }
    s << indent << "O_Jac_EE[]" << std::endl;
    for (size_t i = 0; i < v.O_Jac_EE.size(); ++i)
    {
      s << indent << "  O_Jac_EE[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_Jac_EE[i]);
    }
    s << indent << "O_T_EE_d[]" << std::endl;
    for (size_t i = 0; i < v.O_T_EE_d.size(); ++i)
    {
      s << indent << "  O_T_EE_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_T_EE_d[i]);
    }
    s << indent << "F_T_EE[]" << std::endl;
    for (size_t i = 0; i < v.F_T_EE.size(); ++i)
    {
      s << indent << "  F_T_EE[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_T_EE[i]);
    }
    s << indent << "F_T_NE[]" << std::endl;
    for (size_t i = 0; i < v.F_T_NE.size(); ++i)
    {
      s << indent << "  F_T_NE[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_T_NE[i]);
    }
    s << indent << "NE_T_EE[]" << std::endl;
    for (size_t i = 0; i < v.NE_T_EE.size(); ++i)
    {
      s << indent << "  NE_T_EE[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.NE_T_EE[i]);
    }
    s << indent << "EE_T_K[]" << std::endl;
    for (size_t i = 0; i < v.EE_T_K.size(); ++i)
    {
      s << indent << "  EE_T_K[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.EE_T_K[i]);
    }
    s << indent << "time: ";
    Printer<double>::stream(s, indent + "  ", v.time);
    s << indent << "robot_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.robot_mode);
    s << indent << "current_errors: ";
    s << std::endl;
    Printer< ::franka_msgs::Errors_<ContainerAllocator> >::stream(s, indent + "  ", v.current_errors);
    s << indent << "last_motion_errors: ";
    s << std::endl;
    Printer< ::franka_msgs::Errors_<ContainerAllocator> >::stream(s, indent + "  ", v.last_motion_errors);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FRANKA_CORE_MSGS_MESSAGE_ROBOTSTATE_H
